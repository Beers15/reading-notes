[Home](README.md)

# Readings: Getting Ready for 401:

### The course's preparatory readings were as follows. 

* Simple Programmer - how to solve programming problems<sup>1</sup>

* Pretend Your Time is Worth $1,000/Hour and You’ll Become 100x More Productive<sup>2</sup>

* How to think like a programmer — lessons in problem solving<sup>3</sup>

* 5 Whys<sup>4</sup>


###### All these readings essentially discuss how to properly solve problems and learn more effectively/efficiently. 

###### I give a brief tutorial on problem solving, as I understand it from the readings.


----

* One of the key points from the readings was the difference between busywork and focused work. 

    Business can be a sign of weakness and mental laziness <sup>2</sup>. Time is valuable oh so valuable. By being focused, 
    
    methodical, and calculated, we can do much more in much less time. This definitely applies to solving 
    
    algoritmic problems. There are some steps to take when taking on programming problems, especially under 
    
    time constraints and the pressure that comes from high stake interviews. There are many variations of the steps 
    
    listed in the section below, but they generally advise a similar approach. All in all, the problem solving steps coupled 
    
    with the mentality on time managment touched on here will promote success when solving problems.
    

### Problem Solving Steps
----

The Articles listed below were used for summarizing these ideas <sup>1, 3</sup>.

1) Read the problem **at least 2 times**. The importance of this step is often underestimated. It's tempting to jump 

    in and start coding, but by resisting this urge and spending a lot of time on this step will you will save yourself 
    
    from almost certain doom. In the realm of coding interviews, the ability to understand the problem and come up with 
    
    a well thought out 'gameplan' will show maturity as a developer. On the other hand, diving into a problem with scrambled
    
    code and having to backtrack numerous times when things don't work out will show inexperience and will most likely be 
    
    a much more stressful experience.


2) Once you understand the task at hand, **‘examplify’** it. By this I mean shoot some inputs at the problem you now

    understand and figure out the expected outputs as well as how you got them. Going back to this step later once your 
    
    solution is nearly complete to test edge cases and unusual inputs is an excellent idea as well.


3) Now you're ready to manually solve the problem. List out the steps that are needed. While doing this it is especially important to

    break down the problem into subproblems and tackle them by order of simplicity. To state the obvious, smaller problems are easier 
    
    to solve than larger ones. If a subproblem is still too challenging, break it down even further into baby steps that are solvable. 
    
    The readings mentioned using an approach similar to mathematical induction to accomplish this. Solving the problem for an input 
    
    of size 1 or 2 in order to grasp a concept, and then applying your micro-solution to larger and larger inputs up to an 
    
    input of size 'N' is a very valid problem solving approach. Once you've finished this divide and conquer approach, take your 
    
    solved subproblems and put the pieces back together to create a solution for the larger problem <sup>3</sup>. 
    
    
        There is some consensus that up to 70% of your time should be spent on these first steps 1



4) Finally, it is time to turn your thoughts into actual code. If the first 3 steps were done correctly, you shouldn't be stumped on this 

    (assuming you have a good grasp on your chosen language's syntax and data structures).
  

5) Optimize your code by making sure it can handle all input required and is highly modular. If time permits, refactor your solution 

    to have a lower time complexity and/or space complexity. By following these steps, and enough practice, a programmer should 
    
    be able to demystify even the most complciated problems. 




## Things I want to know more about
---------------
* The steps above are clear to me and provide a general workflow for problem solving. I'd like to know more about the common techniques that are used when solving algorithmic techniques.



###### Works Cited

<sup>1</sup> Sonmez, John, _How to Solve Programming Problems_, Simple Programmer, Jan 8 2011, https://simpleprogrammer.com/solving-problems-breaking-it-down/

<sup>2</sup> Moore, Anthony, _Pretend Your Time is Worth $1,000/Hour and You’ll Become 100x More Productive_, Start it up, Medium, Jan 17 2019, https://medium.com/swlh/pretend-your-time-is-worth-1-000-hour-and-youll-become-100x-more-productive-f04628bb3e6d

<sup>3</sup> Reis, Richard, _How to think like a programmer — lessons in problem solving_, freeCodeCamp, April 10, 2018, https://www.freecodecamp.org/news/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2/

<sup>4</sup> Mind Tools Content Team, _5 Whys_, MindTools, emerald WORKS, https://www.mindtools.com/pages/article/newTMC_5W.htm
